
登录 立即注册
TCP/IP详解资讯动态社区技术精选首页
其它分享即时通讯网›专项技术区›其它分享从根上理解高性能、高并发(六)：通俗易懂，高性能服务器 ...
帖子
请输入搜索内容

本文目录
1、系列文章引言
1.1文章目的
1.2文章源起
1.3文章目录
1.4本篇概述
2、本文作者
3、正文引言
4、多进程
5、多线程
6、事件驱动：Event Loop
7、事件来源：IO多路复用
8、问题：阻塞式IO
9、解决方法：非阻塞式IO
10、基于事件驱动并行编程的难点
11、更好的方法
12、本文小结
附录：更多高性能、高并发文章精选
打赏
分享
发表
评论
5
想开发IM：买成品怕坑？租第3方怕贵？找开源自已撸？尽量别走弯路了...
找站长给点建议
推荐 方案：MobileIMSDK框架、RainbowChat产品、RainbowChat-Web产品 / 签到领积分！ / 官方技术交流群：215477170
精华
从根上理解高性能、高并发(六)：通俗易懂，高性能服务器到底是如何实现的
阅读（3074） | 评论（5）收藏1 淘帖1 赞2
JackJiang Lv.9 精华之王 白金版主 终身成就 7 天前 | |只看大图
微信扫一扫关注！
本文原题“高并发高性能服务器是如何实现的”，本次收录已征得作者同意，转载请联系作者。即时通讯网收录时有改动。


1、系列文章引言

1.1文章目的

作为即时通讯技术的开发者来说，高性能、高并发相关的技术概念早就了然与胸，什么线程池、零拷贝、多路复用、事件驱动、epoll等等名词信手拈来，又或许你对具有这些技术特征的技术框架比如：Java的Netty、Php的workman、Go的gnet等熟练掌握。但真正到了面视或者技术实践过程中遇到无法释怀的疑惑时，方知自已所掌握的不过是皮毛。

返璞归真、回归本质，这些技术特征背后的底层原理到底是什么？如何能通俗易懂、毫不费力真正透彻理解这些技术背后的原理，正是《从根上理解高性能、高并发》系列文章所要分享的。

1.2文章源起

我（Jack Jiang）为即时通讯网整理了相当多有关IM、消息推送等即时通讯技术相关的资源和文章，从最开始的开源IM框架MobileIMSDK，到网络编程经典巨著《TCP/IP详解》的在线版本，再到IM开发纲领性文章《新手入门一篇就够：从零开发移动端IM》，以及网络编程由浅到深的《网络编程懒人入门》、《脑残式网络编程入门》、《高性能网络编程》、《不为人知的网络编程》系列文章。

越往知识的深处走，越觉得对即时通讯技术了解的太少。于是后来，为了让开发者门更好地从基础电信技术的角度理解网络（尤其移动网络）特性，我跨专业收集整理了《IM开发者的零基础通信技术入门》系列高阶文章。这系列文章已然是普通即时通讯开发者的网络通信技术知识边界，加上之前这些网络编程资料，解决网络通信方面的知识盲点基本够用了。

对于即时通讯IM这种系统的开发来说，网络通信知识确实非常重要，但回归到技术本质，实现网络通信本身的这些技术特征：包括上面提到的线程池、零拷贝、多路复用、事件驱动等等，它们的本质是什么？底层原理又是怎样？这就是整理本系列文章的目的，希望对你有用。

1.3文章目录

《从根上理解高性能、高并发(一)：深入计算机底层，理解线程与线程池》
《从根上理解高性能、高并发(二)：深入操作系统，理解I/O与零拷贝技术》
《从根上理解高性能、高并发(三)：深入操作系统，彻底理解I/O多路复用》
《从根上理解高性能、高并发(四)：深入操作系统，彻底理解同步与异步》
《从根上理解高性能、高并发(五)：深入操作系统，理解高并发中的协程》
《从根上理解高性能、高并发(六)：通俗易懂，高性能服务器到底是如何实现的》（* 本文）

1.4本篇概述

接上篇《从根上理解高性能、高并发(五)：深入操作系统，理解高并发中的协程》，本篇是高性能、高并发系列的第6篇文章（也是完结篇）。

本篇是本系列文章的完结篇，你将能了解到，一个典型的服务器端是如何利用前5篇中讲解的各单项技术从而实现高性能高并发的。

本文已同步发布于“即时通讯技术圈”公众号，欢迎关注。公众号上的链接是：点此进入。
2、本文作者

应作者要求，不提供真名，也不提供个人照片。

本文作者主要技术方向为互联网后端、高并发高性能服务器、检索引擎技术，网名是“码农的荒岛求生”，公众号“码农的荒岛求生”。感谢作者的无私分享。
3、正文引言

当你在阅读本篇文章的时候，有没有想过，服务器是怎么把这篇文章发送给你的呢？

说起来很简单：不就是一个用户请求吗？服务器根据请求从数据库中捞出这篇文章，然后通过网络发回去吗。

其实有点复杂：服务器端到底是如何并行处理成千上万个用户请求的呢？这里面又涉及到哪些技术呢？

这篇文章就是来为你解答这个问题的。

从根上理解高性能、高并发(六)：通俗易懂，高性能服务器到底是如何实现的_111.png
4、多进程

历史上最早出现也是最简单的一种并行处理多个请求的方法就是利用多进程。

比如在Linux世界中，我们可以使用fork、exec等系统调用创建多个进程，我们可以在父进程中接收用户的连接请求，然后创建子进程去处理用户请求。

就像这样：
从根上理解高性能、高并发(六)：通俗易懂，高性能服务器到底是如何实现的_1.png

这种方法的优点就在于：

1）编程简单，非常容易理解；
2）由于各个进程的地址空间是相互隔离的，因此一个进程崩溃后并不会影响其它进程；
3）充分利用多核资源。

多进程并行处理的优点很明显，但是缺点同样明显：

1）各个进程地址空间相互隔离，这一优点也会变成缺点，那就是进程间要想通信就会变得比较困难，你需要借助进程间通信（IPC，interprocess communications）机制，想一想你现在知道哪些进程间通信机制，然后让你用代码实现呢？显然，进程间通信编程相对复杂，而且性能也是一大问题；
2）我们知道创建进程开销是比线程要大的，频繁的创建销毁进程无疑会加重系统负担。

幸好，除了进程，我们还有线程。

从根上理解高性能、高并发(六)：通俗易懂，高性能服务器到底是如何实现的_2222.jpg
5、多线程

不是创建进程开销大吗？不是进程间通信困难吗？这些对于线程来说统统不是问题。

什么？你还不了解线程，赶紧看看这篇《深入计算机底层，理解线程与线程池》，这里详细讲解了线程这个概念是怎么来的。

由于线程共享进程地址空间，因此线程间通信天然不需要借助任何通信机制，直接读取内存就好了。

线程创建销毁的开销也变小了，要知道线程就像寄居蟹一样，房子（地址空间）都是进程的，自己只是一个租客，因此非常的轻量级，创建销毁的开销也非常小。

从根上理解高性能、高并发(六)：通俗易懂，高性能服务器到底是如何实现的_2.jpg

我们可以为每个请求创建一个线程，即使一个线程因执行I/O操作——比如读取数据库等——被阻塞暂停运行也不会影响到其它线程。

就像这样：
从根上理解高性能、高并发(六)：通俗易懂，高性能服务器到底是如何实现的_3.png

但线程就是完美的、包治百病的吗，显然，计算机世界从来没有那么简单。

由于线程共享进程地址空间，这在为线程间通信带来便利的同时也带来了无尽的麻烦。

正是由于线程间共享地址空间，因此一个线程崩溃会导致整个进程崩溃退出，同时线程间通信简直太简单了，简单到线程间通信只需要直接读取内存就可以了，也简单到出现问题也极其容易，死锁、线程间的同步互斥、等等，这些极容易产生bug，无数程序员宝贵的时间就有相当一部分用来解决多线程带来的无尽问题。

虽然线程也有缺点，但是相比多进程来说，线程更有优势，但想单纯的利用多线程就能解决高并发问题也是不切实际的。

因为虽然线程创建开销相比进程小，但依然也是有开销的，对于动辄数万数十万的链接的高并发服务器来说，创建数万个线程会有性能问题，这包括内存占用、线程间切换，也就是调度的开销。

因此，我们需要进一步思考。

从根上理解高性能、高并发(六)：通俗易懂，高性能服务器到底是如何实现的_333.jpg
6、事件驱动：Event Loop

到目前为止，我们提到“并行”二字就会想到进程、线程。

但是：并行编程只能依赖这两项技术吗？并不是这样的！

还有另一项并行技术广泛应用在GUI编程以及服务器编程中，这就是近几年非常流行的事件驱动编程：event-based concurrency。

PS：搞IM服务端开发的程序员肯定不陌生，著名的Java NIO高性能网络编程框架Netty中EvenLoop 这个接口意味着什么（有关Netty框架的高性能原理可以读这篇《新手入门：目前为止最透彻的的Netty高性能原理和框架架构解析》）。

大家不要觉得这是一项很难懂的技术，实际上事件驱动编程原理上非常简单。

这一技术需要两种原料：

1）event；
2）处理event的函数，这一函数通常被称为event handler；

剩下的就简单了：你只需要安静的等待event到来就好，当event到来之后，检查一下event的类型，并根据该类型找到对应的event处理函数，也就是event handler，然后直接调用该event handler就好了。

从根上理解高性能、高并发(六)：通俗易懂，高性能服务器到底是如何实现的_4.png

That's it !

以上就是事件驱动编程的全部内容，是不是很简单！

从上面的讨论可以看到：我们需要不断的接收event然后处理event，因此我们需要一个循环（用while或者for循环都可以），这个循环被称为Event loop。

使用伪代码表示就是这样：
1
2
3
4
while(true) {
event = getEvent();
handler(event);
}

Event loop中要做的事情其实是非常简单的，只需要等待event的带来，然后调用相应的event处理函数即可。

注意：这段代码只需要运行在一个线程或者进程中，只需要这一个event loop就可以同时处理多个用户请求。

有的同学可以依然不明白：为什么这样一个event loop可以同时处理多个请求呢？

原因很简单：对于网络通信服务器来说，处理一个用户请求时大部分时间其实都用在了I/O操作上，像数据库读写、文件读写、网络读写等。当一个请求到来，简单处理之后可能就需要查询数据库等I/O操作，我们知道I/O是非常慢的，当发起I/O后我们大可以不用等待该I/O操作完成就可以继续处理接下来的用户请求。

从根上理解高性能、高并发(六)：通俗易懂，高性能服务器到底是如何实现的_5.png

现在你应该明白了吧：虽然上一个用户请求还没有处理完我们其实就可以处理下一个用户请求了，这也是并行，这种并行就可以用事件驱动编程来处理。

这就好比餐厅服务员一样：一个服务员不可能一直等上一个顾客下单、上菜、吃饭、买单之后才接待下一个顾客，服务员是怎么做的呢？当一个顾客下完单后直接处理下一个顾客，当顾客吃完饭后会自己回来买单结账的。

看到了吧：同样是一个服务员也可以同时处理多个顾客，这个服务员就相当于这里的Event loop，即使这个event loop只运行在一个线程(进程)中也可以同时处理多个用户请求。

相信你已经对事件驱动编程有一个清晰的认知了，那么接下来的问题就是，这个事件也就是event该怎么获取呢？
7、事件来源：IO多路复用

在《深入操作系统，彻底理解I/O多路复用》这篇文章中我们知道，在Linux/Unix世界中一切皆文件，而我们的程序都是通过文件描述符来进行I/O操作的，当然对于网络编程中的socket也不例外。

那我们该如何同时处理多个文件描述符呢？

IO多路复用技术正是用来解决这一问题的：通过IO多路复用技术，我们一次可以监控多个文件描述，当某个“文件”（实际可能是im网络通信中socket）可读或者可写的时候我们就能得到通知啦。

这样IO多路复用技术就成了event loop的原材料供应商，源源不断的给我们提供各种event，这样关于event来源的问题就解决了。

从根上理解高性能、高并发(六)：通俗易懂，高性能服务器到底是如何实现的_6.png

当然：关于IO多路复用技术的详细讲解请参见《深入操作系统，彻底理解I/O多路复用》，本文作为纲领性文章，就不再赘述了。

至此：关于利用事件驱动来实现并发编程的所有问题都解决了吗？event的来源问题解决了，当得到event后调用相应的handler，看上去大功告成了。

想一想还有没有其它问题？

从根上理解高性能、高并发(六)：通俗易懂，高性能服务器到底是如何实现的_444.png
8、问题：阻塞式IO

现在：我们可以使用一个线程（进程）就能基于事件驱动进行并行编程，再也没有了多线程中让人恼火的各种锁、同步互斥、死锁等问题了。

但是：计算机科学中从来没有出现过一种能解决所有问题的技术，现在没有，在可预期的将来也不会有。

那上述方法有什么问题吗？

不要忘了，我们event loop是运行在一个线程（进程），这虽然解决了多线程问题，但是如果在处理某个event时需要进行IO操作会怎么样呢？

在《深入操作系统，理解I/O与零拷贝技术》一文中，我们讲解了最常用的文件读取在底层是如何实现的，程序员最常用的这种IO方式被称为阻塞式IO。

也就是说：当我们进行IO操作，比如读取文件时，如果文件没有读取完成，那么我们的程序（线程）会被阻塞而暂停执行，这在多线程中不是问题，因为操作系统还可以调度其它线程。

但是：在单线程的event loop中是有问题的，原因就在于当我们在event loop中执行阻塞式IO操作时整个线程（event loop）会被暂停运行，这时操作系统将没有其它线程可以调度，因为系统中只有一个event loop在处理用户请求，这样当event loop线程被阻塞暂停运行时所有用户请求都没有办法被处理。你能想象当服务器在处理其它用户请求读取数据库导致你的请求被暂停吗？

从根上理解高性能、高并发(六)：通俗易懂，高性能服务器到底是如何实现的_7.png

因此：在基于事件驱动编程时有一条注意事项，那就是不允许发起阻塞式IO。

有的同学可能会问，如果不能发起阻塞式IO的话，那么该怎样进行IO操作呢？

PS：有阻塞式IO，就有非阻塞式IO。我们继续往下讨论。
9、解决方法：非阻塞式IO

为克服阻塞式IO所带来的问题，现代操作系统开始提供一种新的发起IO请求的方法，这种方法就是异步IO。对应的，阻塞式IO就是同步IO，关于同步和异步这两个概念可以参考《从根上理解高性能、高并发(四)：深入操作系统，彻底理解同步与异步》。

异步IO时，假设调用aio_read函数（具体的异步IO API请参考具体的操作系统平台），也就是异步读取，当我们调用该函数后可以立即返回，并继续其它事情，虽然此时该文件可能还没有被读取，这样就不会阻塞调用线程了。此外，操作系统还会提供其它方法供调用线程来检测IO操作是否完成。

就这样，在操作系统的帮助下IO的阻塞调用问题也解决了。

从根上理解高性能、高并发(六)：通俗易懂，高性能服务器到底是如何实现的_555.png
10、基于事件驱动并行编程的难点

虽然有异步IO来解决event loop可能被阻塞的问题，但是基于事件编程依然是困难的。

首先：我们提到，event loop是运行在一个线程中的，显然一个线程是没有办法充分利用多核资源的，有的同学可能会说那就创建多个event loop实例不就可以了，这样就有多个event loop线程了，但是这样一来多线程问题又会出现。

另一点在于编程方面，在《从根上理解高性能、高并发(四)：深入操作系统，彻底理解同步与异步》这篇文章中我们讲到过，异步编程需要结合回调函数（这种编程方式需要把处理逻辑分为两部分：一部分调用方自己处理，另一部分在回调函数中处理），这一编程方式的改变加重了程序员在理解上的负担，基于事件编程的项目后期会很难扩展以及维护。

那么有没有更好的方法呢？

要找到更好的方法，我们需要解决问题的本质，那么这个本质问题是什么呢？

从根上理解高性能、高并发(六)：通俗易懂，高性能服务器到底是如何实现的_888.jpg
11、更好的方法

为什么我们要使用异步这种难以理解的方式编程呢？

是因为：阻塞式编程虽然容易理解但会导致线程被阻塞而暂停运行。

那么聪明的你一定会问了：有没有一种方法既能结合同步IO的简单理解又不会因同步调用导致线程被阻塞呢？

答案是肯定的：这就是用户态线程（user level thread），也就是大名鼎鼎的协程（关于协程请详读本系列的上篇《从根上理解高性能、高并发(五)：深入操作系统，理解高并发中的协程》，本文就不再赘述了）。

虽然基于事件编程有这样那样的缺点，但是在当今的高性能高并发服务器上基于事件编程方式依然非常流行，但已经不是纯粹的基于单一线程的事件驱动了，而是 event loop + multi thread + user level thread。

关于这一组合，同样值得拿出一篇文章来讲解，我们将在后续文章中详细讨论。

从根上理解高性能、高并发(六)：通俗易懂，高性能服务器到底是如何实现的_666.png
12、本文小结

高并发技术从最开始的多进程一路演进到当前的事件驱动，计算机技术就像生物一样也在不断演变进化，但不管怎样，了解历史才能更深刻的理解当下。希望这篇文章能对大家理解高并发服务器有所帮助。

从根上理解高性能、高并发(六)：通俗易懂，高性能服务器到底是如何实现的_777.png
附录：更多高性能、高并发文章精选

《高性能网络编程(一)：单台服务器并发TCP连接数到底可以有多少》
《高性能网络编程(二)：上一个10年，著名的C10K并发连接问题》
《高性能网络编程(三)：下一个10年，是时候考虑C10M并发问题了》
《高性能网络编程(四)：从C10K到C10M高性能网络应用的理论探索》
《高性能网络编程(五)：一文读懂高性能网络编程中的I/O模型》
《高性能网络编程(六)：一文读懂高性能网络编程中的线程模型》
《高性能网络编程(七)：到底什么是高并发？一文即懂！》
《以网游服务端的网络接入层设计为例，理解实时通信的技术挑战》
《知乎技术分享：知乎千万级并发的高性能长连接网关技术实践》
《淘宝技术分享：手淘亿级移动端接入层网关的技术演进之路》
《一套海量在线用户的移动端IM架构设计实践分享(含详细图文)》
《一套原创分布式即时通讯(IM)系统理论架构方案》
《微信后台基于时间序的海量数据冷热分级架构设计实践》
《微信技术总监谈架构：微信之道——大道至简(演讲全文)》
《如何解读《微信技术总监谈架构：微信之道——大道至简》》
《快速裂变：见证微信强大后台架构从0到1的演进历程（一）》
《17年的实践：腾讯海量产品的技术方法论》
《腾讯资深架构师干货总结：一文读懂大型分布式系统设计的方方面面》
《以微博类应用场景为例，总结海量社交系统的架构设计步骤》
《新手入门：零基础理解大型分布式架构的演进历史、技术原理、最佳实践》
《从新手到架构师，一篇就够：从100到1000万高并发的架构演进之路》
即时通讯网 - 即时通讯开发者社区！ 来源：即时通讯网 - 即时通讯开发者社区！

标签:高并发 网络编程
本主题由 JackJiang 于 7 天前 加入精华
上一篇：从根上理解高性能、高并发(五)：深入操作系统，理解高并发中的协程
本帖已收录至以下技术专辑
网络编程(高阶)|主题 22·关注 2
相关文章
从根上理解高性能、高并发(一)：深入计算机底层，理解线程与线程池 从根上理解高性能、高并发(二)：深入操作系统，理解I/O与零拷贝技术 从根上理解高性能、高并发(三)：深入操作系统，彻底理解I/O多路复用 从根上理解高性能、高并发(四)：深入操作系统，彻底理解同步与异步 从根上理解高性能、高并发(五)：深入操作系统，理解高并发中的协程 网络编程入门从未如此简单(一)：假如你来设计网络，会怎么做？
推荐方案
MobileIMSDK-即时通讯网(52im.net)
MobileIMSDK(v4.0精编版)
轻量级开源移动端即时通讯框架。

快速入门 / 性能 / 指南 / 提问

MobileIMSDK-Web-即时通讯网(52im.net)
MobileIMSDK-Web(有偿开源)
轻量级Web端即时通讯框架。

详细介绍 / 精编源码 / 手册教程

RainbowAV-即时通讯网(52im.net)
RainbowAVnew(有偿开源)
移动端实时音视频框架。

详细介绍 / 性能测试 / 安装体验

RainbowChat-即时通讯网(52im.net)
RainbowChat(技术转让)
基于MobileIMSDK的移动IM系统。

详细介绍 / 产品截图 / 安装体验

RainbowChat_Web-即时通讯网(52im.net)
RainbowChat-Web(技术转让)
一套产品级Web端IM系统。

详细介绍 / 产品截图 / 演示视频

评论 5

引用此评论
2 楼: zhangsan Lv.1 5 天前 |
上面说  同样是一个服务员也可以同时处理多个顾客，这个服务员就相当于这里的Event loop，即使这个event loop只运行在一个线程(进程)中也可以同时处理多个用户请求。
下面又说  在单线程的event loop中是有问题的，原因就在于当我们在event loop中执行阻塞式IO操作时整个线程（event loop）会被暂停运行，这时操作系统将没有其它线程可以调度，因为系统中只有一个event loop在处理用户请求，这样当event loop线程被阻塞暂停运行时所有用户请求都没有办法被处理
这两种说法是不是相互矛盾呢？

引用此评论
3 楼: JackJiang Lv.9 精华之王 白金版主 终身成就 楼主 5 天前 |
引用：zhangsan 发表于 2021-01-27 15:16
上面说  同样是一个服务员也可以同时处理多个顾客，这个服务员就相当于这里的Event loop，即使这个event lo ...

你咋看的这么认真呢
签名: 《假如你来设计网络，会怎么做？》：http://www.52im.net/thread-3330-1-1.html

引用此评论
4 楼: zhangsan Lv.1 5 天前 |
引用：JackJiang 发表于 2021-01-27 15:27
你咋看的这么认真呢

楼主 这一点怎么理解？求解

引用此评论
5 楼: zhangsan Lv.1 5 天前 |
上面说的是event loop最终实现的效果。下面说的是实现这种效果的过程中遇到的问题，以及如何解决。是这样吗？楼主

引用此评论
6 楼: 张新宇 Lv.1 5 天前 |
引用：zhangsan 发表于 2021-01-27 15:16
上面说  同样是一个服务员也可以同时处理多个顾客，这个服务员就相当于这里的Event loop，即使这个event lo ...

不矛盾啊。比如这个服务员(EventLoop)只是把菜端到客人桌子上就走，是很快就能给两桌客人提供服务的。但假如有一桌客人需要服务员（EventLoop）贴身服侍，比如站那端茶倒水，那就没空为第二桌客人端菜了。协程我理解就是如果需要端茶倒水就让他们这桌客人自己来吧。
返回列表发新帖发表评论
即时通讯网
实时推送、IM等即时通讯相关技术的学习、交流与分享的平台。专业的资料、专业的人、专业的社区！让即时通讯技术能更好传播与分享。

平等 开放 分享 传承
商务/合作：business@52im.net
投稿/报道：contact@52im.net

友情链接[友链交换]
融云 . GeekOnline
UCloud用户社区
一起开源网
容联云通讯
OpenSNS
网易易盾
环信
关于
关于我们
活跃QQ群
在线文档
网址导航
广告投放 new
微信公众号new
即时通讯网微信公众号

—— 打开微信扫一扫，关注本站的公众号 ——

Copyright © 2014-2020 即时通讯网 - 即时通讯开发者社区 / 版本 V4.4

苏州网际时代信息科技有限公司 (苏ICP备16005070号-1）

